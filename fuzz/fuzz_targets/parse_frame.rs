#![no_main]

use libfuzzer_sys::fuzz_target;

use futures::stream::StreamExt;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::sync::oneshot;
use tokio::sync::oneshot::Sender;

#[derive(Debug)]
struct ArbitraryByteStream {
  data: Vec<u8>,
  tx: Option<Sender<()>>,
}

impl ArbitraryByteStream {
  fn new(data: Vec<u8>, tx: Sender<()>) -> Self {
    Self { data, tx: Some(tx) }
  }
}

impl tokio::io::AsyncRead for ArbitraryByteStream {
  fn poll_read(
    self: Pin<&mut Self>,
    _cx: &mut Context<'_>,
    buf: &mut tokio::io::ReadBuf<'_>,
  ) -> Poll<std::io::Result<()>> {
    let this = self.get_mut();
    let len = std::cmp::min(buf.remaining(), this.data.len());
    let data = this.data.drain(..len).collect::<Vec<_>>();
    buf.put_slice(&data);

    if this.data.is_empty() {
      if let Some(tx) = this.tx.take() {
        let _ = tx.send(()).unwrap();
      }

      return Poll::Pending;
    }

    Poll::Ready(Ok(()))
  }
}

impl tokio::io::AsyncWrite for ArbitraryByteStream {
  fn poll_write(
    self: Pin<&mut Self>,
    _cx: &mut Context<'_>,
    buf: &[u8],
  ) -> Poll<std::io::Result<usize>> {
    Poll::Ready(Ok(buf.len()))
  }

  fn poll_flush(
    self: std::pin::Pin<&mut Self>,
    _cx: &mut Context<'_>,
  ) -> Poll<std::io::Result<()>> {
    Poll::Ready(Ok(()))
  }

  fn poll_shutdown(
    self: std::pin::Pin<&mut Self>,
    _cx: &mut Context<'_>,
  ) -> Poll<std::io::Result<()>> {
    Poll::Ready(Ok(()))
  }
}

fuzz_target!(|data: &[u8]| {
  let (tx, rx) = oneshot::channel();
  let stream = ArbitraryByteStream::new(data.to_vec(), tx);

  let mut ws = framed_websockets::WebSocketServer::after_handshake(stream);

  futures::executor::block_on(async move {
    tokio::select! {
        // We've read all the data, so we're done
        _ = rx => {}
        // We've read a frame, so we're done
        _ = ws.next() => {}
    }
  });
});
